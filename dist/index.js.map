{"mappings":"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","sources":["src/defaultOrigins.ts","src/index.ts"],"sourcesContent":["export const DEFAULT_ORIGIN_LIST = [\"https://hoppscotch.io\"]\n","import { AxiosRequestConfig, AxiosRequestHeaders } from \"axios\"\nimport { DEFAULT_ORIGIN_LIST } from \"./defaultOrigins\"\n\ntype HoppExtensionRequestMeta = {\n  timeData?: {\n    startTime?: number\n    endTime?: number\n  }\n}\n\nlet abortController = new AbortController()\n\nconst convertAxiosHeadersIntoFetchHeaders = (headers: AxiosRequestHeaders) =>\n  Object.entries(headers).reduce((fetchHeaders, [key, value]): HeadersInit => {\n    // setting content-type when using fetch will break the upload unless we provide a proper boundary.\n    // but we omit that header and browser will set the correct boundary itself.\n    return key == \"content-type\" && headers[key] == \"multipart/form-data\"\n      ? { ...fetchHeaders }\n      : {\n          ...fetchHeaders,\n          [key]: value.toString(),\n        }\n  }, <HeadersInit>{})\n\nasync function fetchUsingAxiosConfig(\n  axiosConfig: AxiosRequestConfig<any>\n): Promise<[Response, HoppExtensionRequestMeta]> {\n  const fetchHeaders = convertAxiosHeadersIntoFetchHeaders(axiosConfig.headers)\n\n  const requestMeta: HoppExtensionRequestMeta = { timeData: {} }\n  requestMeta.timeData.startTime = new Date().getTime()\n\n  const params = axiosConfig.params\n\n  if (params && Object.keys(params).length > 0) {\n    try {\n      const url = new URL(axiosConfig.url)\n\n      Object.keys(params).forEach((key) => {\n        url.searchParams.append(key, params[key])\n      })\n\n      axiosConfig.url = url.toString()\n    } catch (_) {}\n  }\n\n  // TODO: check different examples with axios body\n  const res = await fetch(axiosConfig.url, {\n    headers: {\n      ...fetchHeaders,\n    },\n    method: axiosConfig.method,\n\n    // Ignore the body for GET and HEAD requests to prevent error with axios\n    body: [\"get\", \"head\"].includes(axiosConfig.method?.toLowerCase())\n      ? undefined\n      : axiosConfig.data,\n    signal: abortController.signal,\n  })\n\n  requestMeta.timeData.endTime = new Date().getTime()\n\n  return [res, requestMeta]\n}\n\nfunction errorToObject(e: any) {\n  if (e.response && e.response.data) {\n    try {\n      e.response.data = bufferToBase64(e.response.data)\n    } catch (_e) {}\n  }\n\n  // This mess below is a hack to go around Firefox's memory bounding system\n  return {\n    // Standard\n    message: e.message ? JSON.parse(JSON.stringify(e.message)) : undefined,\n    name: e.name ? JSON.parse(JSON.stringify(e.name)) : undefined,\n    // Mozilla\n    fileName: e.fileName ? JSON.parse(JSON.stringify(e.fileName)) : undefined,\n    lineNumber: e.lineNumber\n      ? JSON.parse(JSON.stringify(e.lineNumber))\n      : undefined,\n    columnNumber: e.columnNumber\n      ? JSON.parse(JSON.stringify(e.columnNumber))\n      : undefined,\n    stack: e.stack ? JSON.parse(JSON.stringify(e.stack)) : undefined,\n    // Axios\n    response: e.response ? JSON.parse(JSON.stringify(e.response)) : undefined,\n  }\n}\n\ninterface PWChromeMessage<T> {\n  messageType: \"send-req\" | \"recv-req\" | \"cancel-req\"\n  data: T\n}\n\ninterface RecvRequestMessageData {\n  response: any\n  error: any | null\n  isBinary: boolean\n}\n\nconst convertDataURLToBlob = (dataurl: string) => {\n  const arr = dataurl.split(\",\")\n  const mime = arr[0].match(/:(.*?);/)[1]\n  const bstr = atob(arr[1])\n  let n = bstr.length\n  const u8arr = new Uint8Array(n)\n\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n)\n  }\n\n  const blob = new Blob([u8arr], { type: mime })\n  return blob\n}\n\nconst parseCookieString: (str: string) => { [property: string]: string } = (\n  str\n) =>\n  str\n    .split(\";\")\n    .map((value) => value.split(\"=\"))\n    .reduce((acc, curr) => {\n      if (!!curr[0] && !!curr[1]) {\n        acc[decodeURIComponent(curr[0].trim())] = decodeURIComponent(\n          curr[1].trim()\n        )\n      }\n      return acc\n    }, {} as { [property: string]: string })\n\n// keep track of the cookies we have to delete after the request is made\nlet cookiesToDelete: { url?: string; cookies?: string[] } = {}\nconst removeRequestCookies: () => Promise<void> = async () => {\n  if (!!cookiesToDelete.url && !!cookiesToDelete.cookies) {\n    for (const name of cookiesToDelete.cookies) {\n      await chrome.cookies.remove({\n        url: cookiesToDelete.url,\n        name,\n      })\n    }\n\n    cookiesToDelete = {}\n  }\n}\n\nconst processRequestCookies: (\n  reqConfig: any\n) => Promise<AxiosRequestConfig> = async (reqConfig) => {\n  const cookie = Object.entries(reqConfig.headers || {}).find(\n    ([header]) => header.toLowerCase() === \"cookie\"\n  )\n\n  if (!!cookie && !!reqConfig.url && typeof cookie[1] === \"string\") {\n    cookiesToDelete = { url: reqConfig.url, cookies: [] }\n    const parsedCookies = parseCookieString(cookie[1])\n\n    for (const [name, value] of Object.entries(parsedCookies)) {\n      await chrome.cookies.set({\n        url: reqConfig.url,\n        name,\n        value,\n      })\n      cookiesToDelete.cookies.push(name)\n    }\n  }\n\n  return reqConfig\n}\n\nconst processRequestFormData: (reqConfig: any) => AxiosRequestConfig = (\n  reqConfig\n) => {\n  if (reqConfig.formData || reqConfig.formFiles) {\n    const form = new FormData()\n\n    reqConfig.formFiles.forEach(\n      ({\n        key,\n        value,\n        filename,\n      }: {\n        key: string\n        value: string\n        filename: string\n      }) => {\n        form.append(key, convertDataURLToBlob(value), filename)\n      }\n    )\n\n    reqConfig.formData.forEach(\n      ({ key, value }: { key: string; value: string }) => {\n        form.append(key, value)\n      }\n    )\n\n    reqConfig.data = form\n    reqConfig.formFiles = null\n    reqConfig.formData = null\n  }\n\n  return reqConfig as AxiosRequestConfig\n}\n\nconst processBinaryBody: (\n  reqConfig: any\n) => Promise<AxiosRequestConfig> = async (reqConfig) => {\n  if (reqConfig.binaryContent) {\n    const objectURL = reqConfig.binaryContent.objectURL\n\n    const response = await fetch(objectURL)\n\n    const blob = await response.blob()\n\n    reqConfig.data = new File([blob], reqConfig.binaryContent.name, {})\n  }\n\n  return reqConfig\n}\n\nconst processRequest: (reqConfig: any) => Promise<AxiosRequestConfig> = async (\n  reqConfig\n) => {\n  await processRequestCookies(reqConfig)\n  await processBinaryBody(reqConfig)\n  return processRequestFormData(reqConfig)\n}\n\nfunction bufferToBase64(buffer: any) {\n  return btoa(\n    new Uint8Array(buffer).reduce((data, byte) => {\n      return data + String.fromCharCode(byte)\n    }, \"\")\n  )\n}\n\nconst processDataBasedOnContentType = async (\n  data: string,\n  contentTypeHeader: string\n) => {\n  if (\n    contentTypeHeader &&\n    (contentTypeHeader.startsWith(\"application/json\") ||\n      contentTypeHeader.startsWith(\"application/vnd.api+json\") ||\n      contentTypeHeader.startsWith(\"application/hal+json\"))\n  ) {\n    try {\n      data = JSON.parse(data)\n    } catch (e) {}\n  }\n}\n\nconst getAllFetchResponseHeaders = (\n  fetchHeaders: Headers\n): Record<string, string> => {\n  const headers: Record<string, string> = {}\n\n  fetchHeaders.forEach((value, key) => {\n    headers[key] = value\n  })\n\n  return headers\n}\n\nconst handleSendRequestMessage = async (config: any, tabID?: number) => {\n  try {\n    const processedConfig = await processRequest(config)\n\n    if (config.wantsBinary) {\n      const [r, requestMeta] = await fetchUsingAxiosConfig({\n        ...processedConfig,\n        responseType: \"arraybuffer\",\n        validateStatus: () => true,\n      })\n\n      let headers = getAllFetchResponseHeaders(r.headers)\n\n      return <PWChromeMessage<RecvRequestMessageData>>{\n        messageType: \"recv-req\",\n        data: {\n          response: {\n            status: r.status,\n            statusText: r.statusText,\n            headers,\n            responseURL: r.url,\n            data: bufferToBase64(await r.arrayBuffer()),\n            timeData: requestMeta.timeData,\n          },\n          isBinary: true,\n          error: null,\n        },\n      }\n    } else {\n      const [res, requestMeta] = await fetchUsingAxiosConfig({\n        ...processedConfig,\n      })\n\n      const resText = await res.text()\n      const contentTypeHeader = res.headers.get(\"content-type\")\n\n      const data = await processDataBasedOnContentType(\n        resText,\n        contentTypeHeader\n      )\n\n      let headers = getAllFetchResponseHeaders(res.headers)\n\n      return <PWChromeMessage<RecvRequestMessageData>>{\n        messageType: \"recv-req\",\n        data: {\n          response: {\n            status: res.status,\n            statusText: res.statusText,\n            headers,\n            responseURL: res.url,\n            data: data,\n            timeData: requestMeta.timeData,\n          },\n          isBinary: false,\n          error: null,\n        },\n      }\n    }\n  } catch (e) {\n    return <PWChromeMessage<RecvRequestMessageData>>{\n      messageType: \"recv-req\",\n      data: {\n        response: null,\n        error: errorToObject(e),\n      },\n    }\n  } finally {\n    // revoke the objectURLs, if any\n    // keeping this as an array, cause in the future, if we're adding support for formdata files in a similar way, we can add those objectURLs here\n    const objectURLsToRevoke: string[] = []\n\n    if (config.binaryContent?.objectURL) {\n      objectURLsToRevoke.push(config.binaryContent.objectURL)\n    }\n\n    if (objectURLsToRevoke.length > 0 && tabID) {\n      chrome.tabs.sendMessage(\n        tabID,\n        {\n          action: \"__POSTWOMAN_EXTENSION_REVOKE_OBJECT_URLS__\",\n          objectURLsToRevoke,\n        },\n        () => {}\n      )\n    }\n\n    // remove the cookies set for this request\n    await removeRequestCookies()\n  }\n}\n\nconst cancelRequest = () => {\n  abortController.abort()\n\n  // reset the abort controller for the next request\n  abortController = new AbortController()\n}\n\nchrome.runtime.onMessage.addListener(\n  (message: PWChromeMessage<any>, _sender, sendResponse) => {\n    if (message.messageType === \"send-req\") {\n      handleSendRequestMessage(message.data, _sender.tab.id).then(sendResponse)\n      return true\n    } else if (message.messageType === \"cancel-req\") {\n      cancelRequest()\n      return true\n    }\n  }\n)\n\nlet originList: string[] = []\n\nchrome.storage.sync.get((items) => {\n  originList = JSON.parse(items[\"originList\"])\n})\n\nchrome.storage.onChanged.addListener((changes, _areaName) => {\n  if (changes.originList && changes.originList.newValue) {\n    originList = JSON.parse(changes.originList.newValue)\n  }\n})\n\nchrome.tabs.onUpdated.addListener((_id, _info, tab) => {\n  if (tab.status !== \"loading\") {\n    chrome.tabs.sendMessage(\n      tab.id,\n      {\n        action: \"__POSTWOMAN_EXTENSION_PING__\",\n      },\n      (_response: boolean) => {\n        if (chrome.runtime.lastError) {\n          chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            files: [\"contentScript.js\"],\n          })\n        } else {\n          console.log(\"Already hooked\")\n        }\n      }\n    )\n  }\n})\n\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.storage.sync.get((items) => {\n    if (!items.originList) {\n      chrome.storage.sync.set(\n        {\n          originList: JSON.stringify(DEFAULT_ORIGIN_LIST),\n        },\n        () => {}\n      )\n    }\n  })\n})\n\nchrome.runtime.onMessage.addListener((message, sender) => {\n  if (message.type && message.type == \"execute_hook\" && sender.tab.id) {\n    const files =\n      message.origin_type == \"VALID_ORIGIN\"\n        ? [\"hookContent.js\"]\n        : [\"hookContentInvalidOrigin.js\"]\n\n    chrome.scripting.executeScript({\n      target: {\n        tabId: sender.tab.id,\n      },\n      files,\n      world: \"MAIN\",\n    })\n  }\n})\n"],"names":[],"version":3,"file":"index.js.map"}